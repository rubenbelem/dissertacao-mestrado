% ----------------------------------------------------------
% Introdução
% ----------------------------------------------------------
% \chapter*[Introdução]{Introdução}
\cleardoublepage
\chapter{Introdução}
% \addcontentsline{toc}{chapter}{Introdução}

A forma tradicional de utilizar sistemas de busca é realizar consultas por meio de palavras-chave a partir das quais o sistema responde com resultados potencialmente relevantes para o usuário. Se o usuário não sabe exatamente como expressar a sua consulta ele pode refiná-la e aprimorá-la por meio de ``tentativa e erro'' até que encontre a informação que se está buscando, o que pode tornar o processo demorado e sujeito a erros. A complementação automática de consultas é um mecanismo que pode auxiliar usuários na tarefa de busca e que tem sido amplamente adotado atualmente. Essa funcionalidade consiste em, a partir de um prefixo já digitado pelo usuário, tentar ``advinhar'' a consulta final que será digitada \citep{santo2015}. Com isso, não é necessário escrever toda a consulta, o que além de poupar tempo, pode ajudar a formular uma consulta mais precisa.

\begin{figure}[htbp]
    \centering
    \begin{subfigure}[b]{0.49\textwidth}
        \includegraphics[width=\textwidth]{figures/autocomplete_example1.png}
        \caption{Exemplo de complementação automática de consultas comum.}
        \label{fig:common_autocomplete}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
        \includegraphics[width=\textwidth]{figures/autocomplete_example2.png}
        \caption{Exemplo de complementação automática de consultas tolerante a erros.}
        \label{fig:error_tolerant_autocomplete}
    \end{subfigure}
    \caption{Complementação automática de consultas em uma plataforma de \textit{e-commerce}. }
    \label{fig:query_autocompletion_example}
\end{figure}


A complementação automática de consultas pode ocorrer de duas formas. A primeira está representada na Figura~\ref{fig:common_autocomplete}, na qual o usuário insere o prefixo de consulta \textit{``sanda''} e o sistema automaticamente sugere cinco possíveis consultas relacionadas cujos prefixos correspondem exatamente ao que foi consultado (destacados em negrito em cada consulta). No entanto, é comum que haja erros de ortografia no conteúdo digitado. Cerca de $10\%$ a $20\%$ das consultas são digitadas erroneamente \citep{broder2009}. Para tratar tais situações é necessário que esses erros sejam considerados na busca pelas sugestões que serão retornadas. Esse problema é denominado complementação automática  tolerante a erros (CATE). Quando o usuário não sabe escrever corretamente uma palavra é provável que ele consulte por um prefixo que contenha erros de digitação. A segunda forma da complementação automática, presente na Figura~\ref{fig:error_tolerant_autocomplete}, representa uma resolução para esse problema. Apesar da digitação errada do prefixo \textit{``sandalha''} o sistema ainda assim foi capaz de exibir sugestões cujos prefixos correspondem aproximadamente ao que foi consultado, pois sua complementação automática de consultas é tolerante a erros. Tal tolerância pode economizar os esforços do usuário de $40\%$ até $60\%$ \citep{ji2009efficient}.

Esse mecanismo pode ser visto como uma versão especializada do problema de casamento de padrão. Nesse problema há uma janela de busca com o mesmo tamanho do padrão $p$ buscado que é movida da esquerda para a direita em um texto $t$. A cada movimento, o padrão $p$ é buscado dentro dessa janela. Esse casamento de padrão pode ser realizado de forma exata, ou aproximada. O problema de casamento exato de padrão é definido como encontrar todas as ocorrências $t_{j',j} = t_{j'}..t_{j}$ de um padrão $p = p_{1},..,p_{m}$ em um texto $t = t_{1},..,t_{n}$, sendo $m \leq n$ \citep{farostringmatching2013}.  

Já o problema de casamento aproximado de padrão é definido como encontrar todas as sub-cadeias de caracteres $t_{j',j} = t_{j'}..t_{j}$ de um texto $t = t_{1},..,t_{n}$ cuja distância de edição para um padrão $P = p_{1},..,p_{m}$ esteja dentro de um limiar $\tau$, ou seja, $ed(t_{j',j}, P) \leq \tau$, sendo $ed(s_{1}, s_{2})$ uma função que calcula a distância de edição entre $s$ e $t$. A distância de edição entre duas cadeias de caracteres $s_{1}$ e $s_{2}$ é definida como \textit{o menor número de operações necessárias para transformar $s_{1}$ em $s_{2}$}. Comumente as operações permitidas nesse contexto são a \textit{inserção}, \textit{deleção} ou \textit{substituição} de um caractere.

Essa versão aproximada do problema de casamento de padrão pode ser aplicada ao problema de CATE. Seja $p$ um prefixo de consulta digitado pelo usuário, $S=\{Q_{1}, Q_{2}, ... , Q_{n}\}$ um conjunto de $n$ cadeias de caracteres que representa todas as possíveis sugestões de consulta, e $\tau$ um limite máximo de distância de edição tolerado. O problema de CATE consiste em encontrar um subconjunto de sugestões $S'$ cujos elementos correspondem à $p$ com no máximo $\tau$ erros. Ou seja, é preciso que cada consulta presente em $S'$ possua pelo menos um prefixo que possa possa ser transformado em $p$ com no máximo $\tau$ operações de edição.

Para exemplificar, seja $\tau = 2$, $p = ``sapatho"$ e S = \textit{\{``sapatilha\ preta'', ``salaminho\ italiano'', ``sapinho\ verde''\}}. De acordo com a definição apresentada acima, o subconjunto de $S$ correspondente às consultas que serão sugeridas será \textit{S' = \{``sapatilha\ preta'', ``sapinho\ verde''\}}. No caso da consulta ``salaminho\ italiano'', seus possíveis prefixos são \textit{\{``s'', ``sa'', ``sal'', ``sala'', ... , ``salaminho italiano''\}}, e nenhum deles pode ser transformado em $p = ``sapatho"$ com no máximo $\tau = 2$ edições, portanto, ela não pode ser retornada como resposta. Por outro lado, a consulta ``sapatilha\ preta'' possui como um de seus prefixos ``sapat'', que pode ser transformado em $p$ com a inserção dos caracteres ``h'' e ``o'' no final (duas operações de inserção). Há também a consulta ``sapinho\ verde'' com o prefixo ``sapinho'', que pode ser transformado em $p$ ao substituir a quarta e quinta letra por ``a'' e ``t'', respectivamente.

A tendência comum entre os melhores métodos propostos recentemente no estado da arte para solucionar esse problema \citep{chaudhuri2009extending,ji2009efficient,li2011efficient, xiao2013efficient,deng2016meta, zhou2016beva} é a de utilizar uma estrutura chamada  \textit{Trie} \citep{fredkintrie1960} para indexar os textos das sugestões de consulta. A \textit{Trie} é uma árvore \textit{M-ária} cujos nós são vetores de tamanho $M$ contendo em suas células caracteres que pertencem a um alfabeto $\Sigma$. O nó raiz $\epsilon$ representa uma cadeia de caracteres vazia. Cada nó em um nível $l$ representa o conjunto de todos os elementos que começam com uma sequência $p$ (que pode ser obtida ao caminhar partindo do nó $\epsilon$ até o nó em questão) de $l$ caracteres. Sendo assim, todos os prefixos em comum dentre os itens indexados compartilham dos mesmos nós. Quando o usuário faz uma consulta por um prefixo, esses métodos utilizam a \textit{Trie} para calcular todos os prefixos similares, e a partir deles sugerir as consultas.

Porém, uma vez que cada nó da árvore pode ter até $|\Sigma|$ filhos, essa estrutura tende a consumir alta quantidade de memória quando a base de consultas indexada é muito grande e não há muitos prefixos em comum entre os itens. Essa situação pode dificultar o uso desses métodos para solucionar o problema de CATE em alguns casos. O método ICAN \citep{ji2009efficient}, por exemplo, ao indexar uma base de aproximadamente $10$ milhões de itens consome $\sim9GB$ de memória. Além disso, o complemento automático de consultas em sistemas de busca deve ocorrer muito rapidamente, de forma quase imperceptível para o usuário. Para isso, cada complementação deve ocorrer em menos de $100ms$ \citep{ji2009efficient}.

Uma possível abordagem para diminuir o uso de memória utilizada para processar as consultas é a estratégia de busca em dois níveis. No primeiro nível é possível realizar a busca em um índice \textit{Trie} que indexa somente uma parte inicial dos textos da base de sugestões de consulta. As folhas encontradas por essa busca podem estar associadas com um conjunto de itens, em vez de um único texto (restante da sugestão de consulta). Então, no segundo nível, cada elemento desse conjunto é analisado (um por um, de forma sequencial) para determinar quais sugestões desse conjunto de fato vão ser sugeridas. 

Costa Xavier \citep{xavier2019} realizou um trabalho preliminar que confirmou a hipótese de que é possível utilizar uma abordagem de busca em dois níveis para o problema de complementação automática de consultas tolerante a erros. Em sequência, Gama Ferreira \citep{berg2020} aprimorou significativamente a busca em dois níveis ao utilizar utilizar o mesmo algoritmo (BEVA) de busca nos dois níveis da \textit{Trie} e ao apresentar uma nova estratégia de inserção de chaves em seu índice que acelera o processamento das consultas por utilizar o sistema de cache das máquinas de maneira mais eficiente. % ideia do "level at a time" -> muito boa :)!

A abordagem em dois níveis pode proporcionar uma ótima redução consumo de memória como dito anteriormente. No entanto, um dos maiores problemas com essa abordagem é o aumento do tempo de processamento necessário para sugerir consultas para um prefixo, pois a classe de complexidade computacional da busca sequencial realizada no segundo nível normalmente está acima da classe de complexidade dos algoritmos de busca que podem ser utilizados nas árvores \textit{Trie} do primeiro nível.

Neste trabalho estudamos alternativas para otimizar a busca em uma abordagem de dois níveis com o objetivo de computar as complementações de consulta tolerando erros, mantendo um bom desempenho aliado à redução da memória utilizada. Investigamos os impactos de uma heurística que visa aproveitar informações de erros de distância de edição provenientes do processamento da consulta no primeiro nível para acelerar o processamento no segundo nível, estudando seus efeitos no tempo de processamento e na acurácia de resultados (medição de quantas sugestões o método deixou de encontrar e quantas sugestões encontradas na verdade não deveriam ser consideradas). 

Para implementar as ideias propostas utilizamos no primeiro nível o algoritmo ICPAN \citep{li2011efficient}, o qual é uma otimização do algoritmo ICAN \citep{ji2009efficient}, para realizar a busca no índice \textit{Trie}. Ambos utilizam uma estratégia incremental que consiste em processar um prefixo de consulta $p=c_{1}c_{2}...c_{x}$ caractere a caractere, e ``ativar'' nós da árvore \textit{Trie} a cada etapa do processamento. Para o i-ésimo caractere processado, cada nó ativo $n$ representa um prefixo cuja distância de edição $\xi_{n}^{p'}$ entre $p'=p[c_{1}..c_{i}]$ é menor ou igual ao limite de tolerância $\tau$ estabelecido. O ICPAN é mais eficiente que o ICAN pois utiliza um conceito de ``nós ativos pivotais'' para reduzir o conjunto de nós ativados durante toda a computação. Essa redução implica que menos itens precisarão ser verificados no segundo nível, e portanto é vantajosa para a abordagem em dois níveis.

Quanto ao segundo nível, criamos a hipótese de que é possível em alguns casos realizar uma busca binária em vez de uma busca sequencial. Então, estudamos o quão efetiva seria uma abordagem que combina a estratégia de realizar tanto buscas sequenciais quanto binárias no segundo nível. Descobrimos no decorrer da pesquisa que apesar dessa estratégia atingir tempos de processamento até 2 vezes mais rápidos do que a abordagem padrão de dois níveis, ela faz o método recuperar itens que não devia, e também o faz deixar de recuperar itens relevantes. No entanto, ao tolerar $\tau=3$ erros de digitação na busca, os métodos que utilizam busca binária podem apresentar bons níveis de acurácia.

\section{Problema de Pesquisa}
\label{sec:research-problem}
A principal hipótese estudada nesta dissertação é a de que é possível implementar um sistema de complementação automática em dois níveis combinando busca sequencial e busca binária no segundo nível, de forma que a eficiência do processamento aumente e que a acurácia dos resultados não seja prejudicada. As propostas apresentadas por \cite{xavier2019} e \cite{berg2020} indicam que a busca em dois níveis é uma abordagem promissora para sistemas de complementação automática. Ao iniciar esta pesquisa, tivemos a ideia de combinar busca binária com sequencial no segundo nível. Apesar de parecer uma ideia simples a princípio, sua implementação trouxe consigo desafios que são apresentados ao longo do trabalho. Nossa pesquisa teve como objetivo responder às seguintes questões de pesquisa: i) É possível adaptar sistemas de busca em dois níveis para tirarem proveito da busca binária no segundo nível? ii) Quais são as adaptações necessárias e limitações de uso da ideia? iii) Há vantagens práticas na combinação de busca binária e busca sequencial no segundo nível?


O restante desta dissertação está organizado da seguinte forma: No Capítulo~\ref{sec:related_work} nós mostramos os trabalhos relacionados e os algoritmos existentes na literatura que abordam o problema de complementação automática de consultas tolerante a erros. No Capítulo~\ref{sec:ref_teorico} introduzimos uma definição formal do problema e apresentamos alguns conceitos necessários para uma compreensão mais completa do trabalho. No Capítulo~\ref{sec:metodo} detalhamos a implementação dos métodos em dois níveis propostos. No Capítulo~\ref{sec:results} apresentamos e analisamos os resultados dos experimentos realizados, e por fim, no Capítulo~\ref{sec:conclusion}, expomos nossas conclusões do trabalho e também possíveis direções para trabalhos futuros.
