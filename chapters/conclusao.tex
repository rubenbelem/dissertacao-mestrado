\chapter{Conclusão}
\label{sec:conclusion}

A complementação automática de consultas tolerante a erros (ou ``CATE'') tem se demonstrado uma funcionalidade importante das aplicações de busca pois auxilia os usuários a encontrar o que procuram. Os métodos mais eficientes para solução do CATE encontrados na literatura utilizam índices de árvore \textit{Trie} em suas soluções, o que pode ocasionar um grande consumo de memória, um recurso limitado e de alto custo. Uma forma de tentar mitigar esse problema é a abordagem de busca em dois níveis, que consiste em dividir o processamento do prefixo de consulta em duas partes. Na primeira parte, realiza-se uma busca tolerante a erros em um índice \textit{Trie} que indexa apenas uma quantidade limitada de $\lambda$ caracteres das sugestões de consulta. Essa busca funciona como um filtro para que restem apenas candidatos de resposta, que serão buscados sequencialmente no segundo nível para serem ou não sugeridos. No entanto, essa busca sequencial realizada no segundo nível pode ser muito custosa e tornar o processamento mais lento. 

Com o objetivo de averiguar se é possível tornar o segundo nível mais eficiente ao combinar busca sequencial com busca binária sem que a acurácia do algoritmo seja prejudicada, propusemos nessa dissertação três métodos de busca em dois níveis que executam o algoritmo  ICPAN no primeiro nível. O primeiro é o IP2L, que utiliza apenas busca sequencial no segundo nível e não apresenta imprecisão nos resultados. Esse modelo serve como uma base de comparação com os outros dois quanto ao tempo de processamento e também acurácia; O segundo é o IP2LB, que utiliza uma combinação de busca sequencial com a binária no segundo nível. A ideia inicial era utilizar busca binária no segundo nível irrestritamente em casos que permitissem comparação exata de caracteres, ou seja, somente quando todos os erros já tiverem sido processados no primeiro nível. No entanto, descobrimos em nossos experimentos iniciais que a busca binária utilizada dessa forma no IP2LB deixa de recuperar alguns resultados que deveria, e também traz outros resultados que não devia. Na tentativa de mitigar essa imprecisão propusemos o terceiro método, chamado IP2LRB, que é em suma uma versão do IP2LB porém com um critério mais restrito para utilização da busca binária que visa tornar mais precisa recuperação das sugestões de consulta.

Descobrimos em nossos experimentos que mesmo possuindo valores rápidos de tempo de processamento (principalmente o IP2LB), os dois métodos que utilizam busca binária não são tão precisos em uma base de dados de um sistema real quando toleram $\tau=1$ e $\tau=2$ erros de digitação, obtendo valores de \textit{F1-Score} entre $86\%$ e $93\%$, tendo como base de comparativo os resultados do método BEVA, atual estado-da-arte. No entanto, ao tolerar $\tau=3$ erros, apresentaram valores de \textit{F1-Score} em torno de $96\%$ com indexação de $\lambda=10$ caracteres no primeiro nível. Nesse cenário o método IP2LB se mostrou 2 vezes mais rápido do que o IP2L. 

Em outro experimento com outra grande base de sugestões em um cenário similar o método IP2LB apresentou uma redução de $20\%$ do tempo de processamento em relação ao ICPAN, método utilizado no primeiro nível. Esses resultados indicam que, em um cenário onde se tolere um pouco de ruído nas respostas de uma consulta em prol de maior eficiência, utilizar a busca binária no segundo nível para $\tau=3$ pode ser bastante vantajoso. Além disso, em grande maioria dos casos os resultados de tempo de processamento dos métodos propostos demonstram-se competitivos com o ICPAN, principalmente quando o tamanho do prefixo consultado é menor do que $\lambda$. Quanto ao consumo de memória, conseguimos atingir um bom resultado obtendo em todos os três métodos uma economia de $30\%$ a $65\$$ em relação aos outros métodos da literatura. O método IP2LRB obteve tempos maiores do que o IP2LB, e ligeiramente menores do que o IP2L, porém sem uma diferença significativa de acurácia em relação ao IP2LB. Esse é um indício de que, tratando-se de utilizar um método de dois níveis com busca binária, é mais vantajoso utilizar a abordagem do IP2LB em um sistema real. 

Para trabalhos futuros há várias direções possíveis. Uma delas é utilizar a estratégia de combinação de busca sequencial e binária do IP2LB, porém com método BEVA no primeiro nível, pois é o atual estado-da-arte; Também e possível estudar um método híbrido que utiliza o IP2L para $\tau \leq 2$ e o IP2LB para $\tau = 3$, já que para $\tau=3$ o tempo de processamento tende a aumentar bastante no IP2L, e o IP2LB apresenta um menor tempo e uma boa acurácia nesse caso; Outra opção que pode ser ainda mais eficiente do que a busca binária é utilizar um índice reverso formado por um vetor de mapas \textit{hash}, cuja primeira posição é referente ao primeiro caractere de cada item da base, a segunda é referente ao segundo caractere, e assim por diante. Cada elemento do vetor mapeia um caractere a um conjunto compactado de \textit{bits} que armazena os \textit{ids} dos itens da base que contêm o caractere referente à posição em que o mapa se encontra no vetor. Então, de forma progressiva e respeitando as relações de posição dos caracteres, esse índice pode ser consultado a cada caractere processado do texto que se quer buscar no segundo nível para no fim obter o conjunto de itens que contenham o padrão buscado. Há ainda a possibilidade de estudar o impacto de outros algoritmos de cálculo de distância entre cadeias de caractere na busca sequencial do segundo nível, como o de Ukkonen \citep{ukkonen1985algorithms} e um ``Autômato de Levenhstein'' \citep{schulz2002fast}, por exemplo.